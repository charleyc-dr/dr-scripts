custom_require.call(%w[common drinfomon common-travel common-items])

class Coordinator
  include DRC
  include DRCT

  def initialize(debug)
    UserVars.coordinator_timers ||= {}
    
    @debug = debug
    @settings = get_settings
    @hunting_tasks = @settings.coordinator_hunting_tasks
    @hunting_tasks.each { |task| task[:type] = :hunting }
    @town_tasks = @settings.coordinator_town_tasks
    @town_tasks.each { |task| task[:type] = :town }
    @cleanup_tasks = @settings.coordinator_hunting_cleanup
    @cleanup_tasks.each { |task| task[:type] = :cleanup }

    prepare_tasks
    
    loop do
      break unless run_next_task
    end
  end

  def run_next_task
    return unless task = get_next_task
    echo("Found task to execute: #{task}") if @debug
    (task[:type] == :hunting) ? run_hunting_task(task) : run_town_task(task)
    update_predicates_for_completed_task(task)
    true
  end

  def get_next_task
    cleanup_task || town_task || hunting_task || default_hunting_task
  end
  
  def cleanup_task
    @cleanup_tasks.select { |task| task[:marked] }.find { |task| predicate_met?(task) }
  end

  def hunting_task
    @hunting_tasks.find { |task| predicate_met?(task) }
  end

  def town_task
    @town_tasks.find { |task| predicate_met?(task) }
  end

  def default_hunting_task
    @hunting_tasks.find { |task| task[:default] }
  end

  def predicate_met?(task)
    echo("Checking predicates for task: #{task}") if @debug
    start = evaluate_predicate?(task[:start_on])
    if start && !(task[:stop_on].nil? || task[:stop_on].empty?)
      start = !evaluate_predicate?(task[:stop_on])
    end
    start
  end

  def evaluate_predicate?(predicate)
    return true if predicate.nil? || predicate.empty?
    unless predicate.size == 1
      raise ArgumentError, "Predicate with multiple keys: #{predicate}"
    end

    key = predicate.keys.first
    value = predicate[key]
    
    case key
    when 'or'
      value.any? { |member| evaluate_predicate?(member) }
    when 'and'
      value.all? { |member| evaluate_predicate?(member) }
    when 'skill_less_than'
      echo("Checking skill #{value['skill']} < #{value['target']}") if @debug
      skill_less_than?(value['skill'], value['target'])
    when 'any_skill_less_than'
      echo("Checking skills #{value['skills']} < #{value['target']}") if @debug
      value['skills'].any? { |skill| skill_less_than?(skill, value['target']) }
    when 'after_every_hunt'
      echo("Checking hunt counter #{value['key']}: #{@hunt_counters[value['key']]}") if @debug
      @hunt_counters[value['key']] > 0
    when 'on_first_run'
      echo("Checking first-run counter #{value['key']}: #{@first_run_counters[value['key']]}") if @debug
      @first_run_counters[value['key']]
    when 'boxes_over'
      get_num_boxes > value
    when 'boxes_under'
      get_num_boxes < value
    when 'encumbrance_over'
      check_encumbrance > value
    when 'timer'
      Time.now > get_time(value)
    when 'predicate'
      unless all_predicates.include? value
        raise ArgumentError, "Predicate not in whitelist: #{value}"
      end
      send(value)
    else
      raise ArgumentError, "Unknown predicate type: #{key}"
    end
  end

  def prepare_tasks
    @local_timers = {}
    @cleanup_tasks.each { |task| task[:marked] = !task[:skip_first_run] }
  end

  def terminal_predicates(task)
    predicates = []
    (predicates << task[:start_on]) if task[:start_on]
    (predicates << task[:stop_on]) if task[:stop_on]
    predicates.map { |pred| terminal_predicates_helper(pred) }.flatten
  end

  def terminal_predicates_helper(predicate)
    return [] if predicate.nil? || predicate.empty?
    unless predicate.size == 1
      raise ArgumentError, "Predicate with multiple keys: #{predicate}"
    end

    key = predicate.keys.first
    value = predicate[key]
    case key
    when 'or', 'and'
      value.map { |member| terminal_predicates_helper(member) }.flatten
    else
      [predicate]
    end    
  end

  def get_timers(task)
    terminal_predicates(task).select { |pred| pred.keys.first == 'timer' }
      .map { |pred| pred['timer'] }
  end

  def update_predicates_for_completed_task(task)
    if task[:type] == :cleanup
      task[:marked] = false
    elsif task[:type] = :hunting
      @cleanup_tasks.each { |task| task[:marked] = true }
    end
    get_timers(task).each { |timer| reset_timer(timer) }
  end
  
  def reset_timer(timer)
    reset_time = Time.now + timer['time']
    if timer['global']
      echo("Resetting global timer: #{timer}") if @debug      
      UserVars.coordinator_timers[timer['key']] = reset_time
    else
      echo("Resetting local timer: #{timer}") if @debug      
      @local_timers[timer['key']] = reset_time
    end
  end

  def get_time(timer)
    if timer['global']
      UserVars.coordinator_timers[timer['key']] || (Time.now - 1)
    else
      @local_timers[timer['key']] || (Time.now - 1)
    end    
  end
  
  def skill_less_than?(skill, target)
    echo("Skill level is #{DRSkill.getxp(skill)}") if @debug
    DRSkill.getxp(skill) < target
  end

  def get_num_boxes
    (get_boxes(@settings.picking_box_source) || []).size    
  end

  def run_town_task(task)
    echo("Running town task #{task}") if @debug
    if action = task[:action]
      unless all_actions.include? action
        raise ArgumentError, "Action not in whitelist: #{action}"
      end
      send(action, task)
    elsif script = task[:script]
      wait_for_script_to_complete(script)
    else
      raise ArgumentError, "Expected action or script: #{task}"
    end
  end
  
  def run_hunting_task(task)
    file = task[:file]
    echo("Starting hunting-buddy with file #{file}") if @debug
    start_script('hunting-buddy', [file])
    pause 5
    next_check = Time.now + 60
    while Script.running?('hunting-buddy')
      if Time.now > next_check
        $HUNTING_BUDDY.stop_hunting if (task[:stop_on] && evaluate_predicate?(task[:stop_on]))
        next_check = Time.now + 60
      end
      pause 5
    end
    safe_room = @settings.safe_room
    if task[:safe_room]
      safe_room = task[:safe_room]['id']
    end
    walk_to(safe_room)
  end
  
  #
  # Predicates
  #  

  def all_predicates
    [
      'hunt_done?',
      'run_crossing_training?',
    ]
  end

  def hunt_done?
    # TODO: would be nice to not have to double-check predicates here.
    !hunting_task
  end
  
  def run_crossing_training?
    @settings.crossing_training.any? { |skill| DRSkill.getxp(skill) < 28 }
  end
  
  #
  # Actions
  #
  def all_actions
    [
      'pick_boxes',
      'crossing_training',
    ]
  end

  def pick_boxes(task)
    walk_to(@settings.lockpick_room_id) if @settings.lockpick_room_id
    wait_for_script_to_complete('pick')
  end

  def crossing_training(task)
    start_script('crossing-training')
    pause 5
    pause 1 while get_next_task[:action] == 'crossing_training'
    $CROSSING_TRAINER.stop
    pause 1 while $CROSSING_TRAINER.running
  end
end

before_dying do
  ['hunting-buddy', 'crossing-training'].each do |script_name|
    stop_script(script_name) if Script.running?(script_name)
  end
end

Coordinator.new(true)
